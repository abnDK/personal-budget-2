## 4.3 Resetting the database
Below we take a closer look into the proces of resetting the database.
The database can be reset with the current data preserved, or it can be rebuild with empty tables. Resetting the database will essentially deliver the database in the newest version available in upfiles (See 4.1 - Migration).


Entry point is db_reset/reset_tables.sh
- reset_database.sh is called.
  - current database is renamed to <name>_old.
    - Uses db_reset/oldify_database.sql
  - new database is created with the name "personal_budget_2"
    - Uses db_reset/create_database.sql
- "0-0" is writted to current_version
  - uses migration/write_version.sh
- Database version 1-0 is writted
  - uses ../models/migration/db_1-0.sql
- Database is migrated up to newest version
  - reads files listed in ../models/migration/upfiles
- if 'data' is given as parameter when calling reset_tables.sh:
  - data from the "_old" version of db is read and copied to the newly created database.
    - uses db_reset/export_import_data.sh

When running reset_tables.sh, queries towards the database will be printed to the terminal. Thus a light debugging can be done reading the output from running the process.

### 4.3.1 Preserving data (export_import_data.sh)
When preserving data, a few important notes to make is:
- As the database consist of several foreign key constraints, it is important to write the data in the right sequence in order not to violate the foreign key constraints.

Entry points is db_reset/export_import_data.sh
- tables names is read from the newly created database and written to db_reset/tablenames
  - uses db_reset/get_tablesnames.sh
    - uses db_reset/get_tablenames.sql
      - gets all table names under the schema "public"
      - tablenames is written to db_reset/tablenames  
- tables are ordered in parent/child relationships representing the foreign key constraints between tables.
  - uses db_reset/order_tables.sh
    - First gets all foreign key constraints
      - uses db_reset/foreign_key_constraints.sql
      - foreign key constraints is written to db_reset/foreign_key_constraints.csv
      - written in format csv with header on first row and the following columns (delimited by ";"):
        - Child;Parent;Foreign key name;Schema
    - db_reset/tablenames is then read and afterwards overwritten with new tableorder.
    - order_tables.sh calls order_tables.js which uses a breadth first search algorithm to list tablenames in generational order (in contrast to depth first search).
      - for detailed documentation of order_tables.sh, see "4.3.2 Order tables"
- For each table in db_reset/tablenames the data is copied from "_old" database to the newly created database.
  - Between each read and write, data is written to db_reset/tabledata in csv format delimited by ";".

### 4.3.2 Order tables

db_reset/order_tables.js is written in javascript in contrast to other db tools written in bash. This is mainly in order to get acces to data structures not available in bash.

db_reset/order_tables.js is called with 2 arguments. First is the path to tablenames file. Second is the path to foreign key constraints csv file.

the main functionality is taking in a list of tables and returning the tables in the same format sorted by foreign key parent/child relationships. Tables are read and written in simple format of tablenames delimeted by newline characters.

File contains 4 main classes:
- Table
- ForeignKeyTree
- pgTableWriter
- pgTableReader

#### Table
- The primary datastructure for tables with 2 properties.   
- Properties:
  - parent: String (essentially the name of the table)
  - children: Array

#### ForeignKeyTree
- Takes in an array of Tables and sorts them either by breath first search (.sortByGeneration()) or by depth first search (.sortByBranch())
- Properties:
  - tables: Array
  - visited: Array
  - queue: Array
  - root: Table(parent='root')
- initialization:
  - besides setting tables property .addRootChildren is run.

- sortByGeneration():
  - uses a queue to keep track of children of tables. Tables is then visited using af FIFO approach essentially resulting in reading the siblings of the current table before reading the its children.
  - initially the root tables is pushed onto the queue.
  - root is read looking for children adding any to the queue.
  - next in queue is a child of root, which then is read for any children.
    - children will be pushed onto the queue
    - table name will be added to the visited array. Every tablename except the root is pushed onto the visited array. This will result in a sorted list of table names with parents being written before it's children.
    - the process of visiting the children in the queue is repeated until no children is left in the queue.

- addRootChildren():
  - tables who does not have a parent (regardless of it being a parent or not) is written as the child of the root table.
  - Used to initialize the sorting algorithm (both "byGeneration" and "byBranch")


#### pgTableReader
- reads tablenames and foreign key constraints file.
- properties:
  - tablesnamesPath: String
  - foreignKeyConstraintsPath: String
- methods:
  - tablesFor(<treestructure>) 
    - input used is a string equal to the class ordering the tables. For now, only 'ForeignKeyTree' is available.
    - returns an unordered array containing all tablenames 

#### pgTableWriter
- takes in tables prepared for ForeignKeyTree class and writes tablenames using .sortByGeneration
- properties:
  - tree: ForeignKeyTree
- methods:
  - write(<writePath>)
    - calls .sortByGeneration on tree
    - writes sorted tables to <writePath>





