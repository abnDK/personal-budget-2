# Analysis: Sort tables - from fkey relationships and tablenames to tree of tables in generational order


Input:
Tables can take one of four forms
1 - Alone
2 - Only child(ren), no parent (children can be one or more)
3 - Only parent, no children
4 - Children and parent (children can be one or more)

For simplification, this can be modelled as 2 different tables:
1 - Alone - A table with no parent or children, only its own name.
2 - Parent - A parent with child(ren). In some cases the child also has a child (when original table had both children and 
parent)

Adding to root:
1 - when the table is "Alone" is has no relation to other tables, and thus can be insterted at root level.
2 - when the table is "Parent" 1 of 2 cases can unfold:
  2.1 - root can be empty: in this case we just add the parent as is
  2.2 - root has children: we search root for existing tables equal to parent, its children or its "grandchildren"
      2.2.1 is it ever important to look for children or grandchildren?

Examples of tables (capital letter represents the original main table):

budget
- test c
- category
- - transaction
- - test a
- - - test b
- - - - test 0

Results in:
test b => TEST 0
category => TRANSACTION
budget => CATEGORY => transaction/test a
BUDGET => category
category => TEST A => test b
test a => TEST B => test 0
test c

B
A
- C
- - D
- - E
- - - F
- - - - G

B
fG
cD
aCd/e
Ac
cEf
eFg

This shows, that tables will at max be modeled with 3 
generations, and tables can represent the same tables (e.g. 
overlapping generations - i.e. cEf and eFg)

//We could model all tables as a parent with kids or parents 
//with kids who has grandkids and develop function that adds 
//missing children to a target table. 

We should model all tables as parent with either grandparent or 
child(ren). 
Functions handling potentially multiple children with 
potentially multiple grandchildren is too complex for now.

I.e. Adding Abc to Ab
- c will be added to Ab thus becoming Abc

If we have Cd
we can add
- aBc
- Bc
- bCd
- cDe
- De
- dEf

6 different cases

1/6: 3gen match on child/grandparent
2/5: 2gen match on child/table 
3/4: 3gen match on table+child/grandparent+table

or

1/2: match on child
3/4: match on table (and on child/parent)
5: match on table
6: match on parent

### IMPLEMENT THIS

mergeFamily:
if match on table:
- check if existingParent == parent
- - add parent if !existingParent
- check if existingChild == child
- - add child if !existingChild

else if table has parent and match on parent:
- add table (if table has child, this will be added as well, no 
questions asked for now, but could we potentially run into 
problems if child is previously added as a parent or table in an 
earlier run?)

else if table has child and mtach on child:
- add table as parent of child (if table has parent, this will 
get added as well). The parent of the child will be redirected 
to become parent of table (if !table.parent) and parent (if 
table.parent).

IMPLEMENT THIS ###

existingParent
existingTable
existingChild

foreignParent
foreignTable
foreignChild

1/6: single match for 3 gen
2/5: single match for 2 gen
3/4: double match for 3 gen
?: if triple match for 3 gen - just skip

Name of function: targetTable.mergeFamily(newTable)


mergeFamily should be able to both add children and parent if 
not represented in root.
Add parent first if newtable has parent.
Call recursivly
If no parent, then try to add children.

Remember that some parents have more children.

So 4 cases:
A
Ab
Abc
Ab/c

according to the above:
- if c is at root level and we try to add Abc:
--- Look for A (if match ? mergeFamily : look for B ? 
mergeFamily : do nothing (if c is found, mergeFamily))






